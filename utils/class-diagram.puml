@startuml class
class PacketData {
    - stop : bool
    - packet : vector<uint8_t>
    - header : pcap_pkthdr
    + getLength() : size_t
    + getCapturedLength() : size_t
    + getTimeStamp() : timeval
    + getData() : uint8_t*
    + getPacket() : vector<uint8_t>&
}

class PacketHandler {
    - queue : ThreadSafeQueue<PacketData>*
    - worker : thread
    + run() : void
    + stop() : void
    + processPacket(packet : PacketData) : void
}

class PacketSniffer {
    - pcapWrapper : IPCAPWrapper*
    - handle : pcap_t*
    - device : string
    - queue : ThreadSafeQueue<PacketData>*
    - protocols : unordered_map<ProtoType, bool>
    - numPackets : int
    - port : int
    - t_portType : PortType
    - protoToFilter : map<ProtoType, string>
    + startCapture() : void
    + createFilter() : string
    + packetHandlerStatic(userData : unsigned char*, pkthdr : pcap_pkthdr*, packet : unsigned char*) : void
}

class ParsingContext {
    - protocol : ProtoType
    - sourceMAC : uint8_t[6]
    - destinationMAC : uint8_t[6]
    - timeStamp : timeval
    - length : size_t
    - sourceIP : IPAddress
    - destinationIP : IPAddress
    - sourcePort : uint16_t
    - destinationPort : uint16_t
    - packet : vector<uint8_t>
    + setProtocol(protocol : ProtoType) : void
    + setSourceMAC(sourceMAC : uint8_t[6]) : void
    + setDestinationMAC(destinationMAC : uint8_t[6]) : void
    + setTimeStamp(timeStamp : timeval) : void
    + setLength(length : size_t) : void
    + setSourceIP(sourceIP : IPAddress) : void
    + setDestinationIP(destinationIP : IPAddress) : void
    + setSourcePort(sourcePort : uint16_t) : void
    + setDestinationPort(destinationPort : uint16_t) : void
    + setPacket(packet : vector<uint8_t>) : void
    + print() : void
}

abstract class Protocol {
    # context : ParsingContext*
    # packet : vector<u_char>
    + process() : void
}

class ProtocolFactory {
    + createProtocol(type : uint16_t, context : ParsingContext*, packet : vector<u_char>) : shared_ptr<Protocol>
}

class ThreadSafeQueue<T> {
    - queue : queue<T>
    - mtx : mutex
    - cond : condition_variable
    + push(value : T) : void
    + pop() : T
    + try_pop(value : T&) : bool
    + empty() : bool
    + size() : size_t
    + print() : void
}

interface IPCAPWrapper {
    + {abstract} open_live(device : char*, snaplen : int, promisc : int, to_ms : int, errbuf : char*) : pcap_t*
    + {abstract} compile(p : pcap_t*, fp : bpf_program*, str : char*, optimize : int, netmask : bpf_u_int32) : int
    + {abstract} setfilter(p : pcap_t*, fp : bpf_program*) : int
    + {abstract} loop(p : pcap_t*, cnt : int, callback : pcap_handler, user : u_char*) : int
    + {abstract} close(p : pcap_t*) : void
}

PacketSniffer "1" --> "1" IPCAPWrapper : uses
PacketSniffer "1" --> "1" ThreadSafeQueue : has
PacketSniffer "1" --> "*" Protocol : uses
PacketHandler "1" --> "1" ThreadSafeQueue : has
PacketHandler "1" --> "*" PacketData : uses
PacketSniffer "1" --> "*" PacketData : uses
PacketHandler "1" --> "1" ParsingContext : uses
Protocol "1" --> "1" ParsingContext : uses
ProtocolFactory "1" --> "*" Protocol : creates
@enduml